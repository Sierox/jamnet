import mido.midifiles.tracks as mitracks
from mido import MidiFile, MidiTrack, Message, MetaMessage
import numpy as np

''' MIDI <-> Roll converter for creating JamNet data-sets and converting JamNet outputs to MIDI. '''

SIGNATURE = "Generated by JamNet Converter"

BASS = [32, 33, 34, 35, 36, 37, 38, 39]
PIANO = [0, 1, 2, 3, 4, 5, 6, 7]
ORGAN = [16, 17, 18, 19, 20, 21, 22, 23]
GUITAR = [24, 25, 26, 27, 28, 29, 30, 31]
SAX = [64, 65, 66, 67, 69]  # nice
BRASS = [56, 57, 58, 59, 60, 61, 62, 63]
CLARINET = [71]
FLUTE = [72, 73]
VIBRAPHONE = [11, 12, 13]
# STRINGS = [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55] # Not used in jazz, maybe for other genres.

# Define which instruments belong to which part
PART_INSTRUMENTS = {"bass": BASS, "acmp": PIANO + ORGAN + GUITAR,
                    "lead": SAX + BRASS + CLARINET + FLUTE + VIBRAPHONE}
# Define output instruments (Common Instruments : 32 = Acoustic Bass, 0 = Piano, 11 = Vibraphone, 26 = Jazz Guitar)
OUTPUT_INSTRUMENTS = {"bass": 32, "acmp": 0, "lead": 11}

# For parsing instruments
PERC_NAMES = ["perc", "drum", "snare", "cymb", "bongo", "shake", "bd", "hh", "kick", "hi-hat", "hihat", "hi hat",
              "stick", "conga", "tamb", "agogo", "tom", "cabasa", "kit", "brush", "bell", "ride", "crash", "hat"]
PERC_SAFE_NAMES = ["org", "chro"]
LEAD_NAMES = ["lead", "melody", "voice"]


def midi_to_rollt(full_raw_midi_dir, downscale_f=64.0):
    """ Converts given MIDI file to roll, also return tempo """
    midif = MidiFile(full_raw_midi_dir)
    roll = _grouped_tracks_to_roll(_parse_midi_tracks(midif), midif, downscale_f)
    tempo = _parse_tempo(midif)
    return roll, tempo


def rollt_to_midi(rollt, full_midi_save_dir, downscale_f=64.0):
    """ Converts the roll and tempo of a piece to a MIDI file. """
    roll, tempo = rollt
    midif = MidiFile(type=1)
    midif.tracks.append(_generate_header_track(tempo))
    roll_dict = {"bass": roll[:, :, 0], "acmp": roll[:, :, 1], "lead": roll[:, :, 2]}
    for channel, part in enumerate(roll_dict):
        midif.tracks.append(_instrument_roll_to_midi_track(roll_dict[part], part, channel, downscale_f))
    midif.save(full_midi_save_dir)
    return midif


def make_jamnet_midi(full_raw_midi_dir, full_jamnet_midi_save_dir, downscale_f=64.0):
    """ Jamnetize raw MIDI file. """
    rollt_to_midi(midi_to_rollt(full_raw_midi_dir, downscale_f), full_jamnet_midi_save_dir, downscale_f)


def _parse_midi_tracks(midif):
    tracks = []
    for i, track in enumerate(midif.tracks):
        track_name = _parse_midi_track_name(track)
        instrument_type = _parse_midi_track_instrument(track)
        if not instrument_type is None:
            is_perc = False
            for perc_name in PERC_NAMES:
                if perc_name in track_name.lower():
                    is_perc = True
                    for perc_safe_name in PERC_SAFE_NAMES:
                        if perc_safe_name in track_name.lower():
                            is_perc = False
                            break

            is_lead = False
            for lead_name in LEAD_NAMES:
                if lead_name in track_name.lower():
                    is_lead = True

            if is_lead:
                tracks.append((i, track_name, 'lead'))
            elif not is_perc:
                tracks.append((i, track_name, instrument_type))

    grouped_tracks = {"bass": list(), "acmp": list(), "lead": list()}
    for id, name, instrument in tracks:
        grouped_tracks[instrument].append(id)
    return grouped_tracks


def _parse_midi_track_instrument(track):
    for msg in track:
        if msg.type == 'program_change':
            for inst_type in PART_INSTRUMENTS:
                for midi_index in PART_INSTRUMENTS[inst_type]:
                    if msg.program == midi_index:
                        return inst_type
    return None


def _parse_midi_track_name(track):
    for msg in track:
        if msg.type == 'track_name':
            return msg.name
        if msg.type == 'text':
            return msg.text
    return "null"


def _parse_tempo(midif):
    for i, track in enumerate(midif.tracks):
        for msg in track:
            if msg.type == "set_tempo":
                return msg.tempo


def _grouped_tracks_to_roll(grouped_tracks, midif, f):
    roll_dict = dict()
    starts = []
    lens = []
    for g in grouped_tracks:
        if grouped_tracks[g]:
            roll_dict[g], start = _parse_notes(
                mitracks.merge_tracks([track for i, track in enumerate(midif.tracks) if i in grouped_tracks[g]]), f)
            starts.append(start)
            if roll_dict[g] is not None:
                lens.append(roll_dict[g].shape[1])
        else:
            roll_dict[g] = None  # No track

    max_len = max(lens)
    for g in roll_dict:
        if roll_dict[g] is None:
            roll_dict[g] = np.zeros((88, max_len), dtype=bool)
        elif roll_dict[g].shape[1] < max_len:
            roll_dict[g] = np.hstack((roll_dict[g], np.zeros((88, max_len - roll_dict[g].shape[1]), dtype=bool)))

    if len(starts) > 1:
        start = min(starts)
        for g in roll_dict:
            roll_dict[g] = np.delete(roll_dict[g], slice(0, start), 1)

    return np.dstack((roll_dict["bass"], roll_dict["acmp"], roll_dict["lead"]))


def _parse_notes(track, f):
    midi_note_messages = []
    for msg in mitracks._to_abstime(track):
        if msg.type == 'note_on' or msg.type == 'note_off':
            midi_note_messages.append(msg)
    start = None
    roll = None
    for i in range(0, len(midi_note_messages)):
        if midi_note_messages[i].type == 'note_on':
            if start is None:
                start = midi_note_messages[i].time
            new = [midi_note_messages[i].note, midi_note_messages[i].time, 0]
            for j in range(i + 1, len(midi_note_messages)):
                if midi_note_messages[j].type == 'note_off' and midi_note_messages[j].note == new[0]:
                    new[2] += midi_note_messages[j].time
                    break
            if 0 < new[0] < 88:
                roll = _add_note_to_roll(roll, new, f)
    return roll, int(start / f)


def _add_note_to_roll(roll, note, f):
    note[1], note[2] = int(note[1] / f), int(note[2] / f)
    if roll is None:
        roll = np.zeros((88, note[2]), dtype=bool)
    elif roll.shape[1] < note[2]:
        roll = np.hstack((roll, np.zeros((88, note[2] - roll.shape[1]), dtype=bool)))
    roll[note[0], note[1]:note[2]] = 1
    return roll


def _generate_header_track(tempo):
    midit = MidiTrack()
    midit.append(MetaMessage("time_signature", numerator=4, denominator=4,
                             clocks_per_click=24, notated_32nd_notes_per_beat=8, time=0))
    midit.append(MetaMessage("set_tempo", tempo=int(tempo / 2), time=0))
    midit.append(MetaMessage("copyright", text=SIGNATURE))
    midit.append(MetaMessage("end_of_track", time=1))
    return midit


def _instrument_roll_to_midi_track(track, part, channel, f):
    messages = [Message(type='program_change', channel=channel, program=OUTPUT_INSTRUMENTS[part], time=0),
                MetaMessage("track_name", name=part, time=0)]
    for note, pitch_line in enumerate(track[:, ]):
        last = 0
        start = 0
        for dt, n in enumerate(pitch_line):
            if last == 0 and n == 1:
                start = dt
            if n == 0 and last == 1:
                messages.append(Message(type="note_on", channel=channel, note=note, velocity=50, time=int(start * f)))
                messages.append(Message(type="note_off", channel=channel, note=note, velocity=0, time=int(dt * f)))
            last = n
    messages.sort(key=lambda msg: msg.time)
    return MidiTrack(mitracks.fix_end_of_track(mitracks._to_reltime(messages)))


def pack_roll(roll):
    # From inefficient 1-byte booleans to efficient 1-byte integers.
    return np.packbits(roll, axis=1)


def unpack_roll(roll):
    return np.unpackbits(roll, axis=1)
