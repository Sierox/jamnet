import torch
import mido.midifiles.tracks as mitracks
from mido import MidiFile, MidiTrack, Message, MetaMessage
import copy
import numpy as np




# OLD VERSION OF midi2jnn.py. Converts to and from a "note array" format instead of tensors.
# Not deleting in case I find a use for this.




''' MIDI <-> JNN converter for creating JamNet data-sets and playing JamNet outputs. '''

SIGNATURE = "Generated by JamNet Converter"

BASS = [32, 33, 34, 35, 36, 37, 38, 39]
PIANO = [0, 1, 2, 3, 4, 5, 6, 7]
ORGAN = [16, 17, 18, 19, 20, 21, 22, 23]
GUITAR = [24, 25, 26, 27, 28, 29, 30, 31]
SAX = [64, 65, 66, 67, 69]  # nice
BRASS = [56, 57, 58, 59, 60, 61, 62, 63]
CLARINET = [71]
FLUTE = [72, 73]
VIBRAPHONE = [11, 12, 13]
# STRINGS = [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55]

INSTRUMENTS = {"bass": BASS, "acmp": PIANO + ORGAN + GUITAR,
               "lead": SAX + BRASS + CLARINET + FLUTE + VIBRAPHONE}
PERC_NAMES = ["perc", "drum", "snare", "cymb", "bongo", "shake", "bd", "hh", "kick", "hi-hat", "hihat", "hi hat",
              "stick", "conga", "tamb", "agogo", "tom", "cabasa", "kit", "brush", "bell", "ride", "crash", "hat"]
PERC_SAFE_NAMES = ["org", "chro"]
LEAD_NAMES = ["lead", "melody", "voice"]
JNN_PIECE_PARTS = ["bass", "acmp", "lead", "tempo"]

# Instruments for output pieces.
JNN_INSTRUMENTS = {"bass": 32, "acmp": 0, "lead": 11}  # 26 = jazz guitar


def midi_to_jnn(full_raw_midi_dir):
    """ MIDI to JNN """
    midif = MidiFile(full_raw_midi_dir)
    midi_tracks = parse_midi_tracks(midif)
    grouped_tracks = group_midi_tracks(midi_tracks)
    jnn_piece = grouped_tracks_to_jnn(grouped_tracks, midif)
    jnn_piece["tempo"] = parse_tempo(midif)
    return jnn_piece


def jnn_to_tensor(jnn_piece):
    np_piece = np.zeros((3, 88, 1))
    for i, g in enumerate(jnn_piece):
        for n in jnn_piece[g]:

            mx = max(mx, n[1] + n[2])


def parse_tempo(midif):
    for i, track in enumerate(midif.tracks):
        for msg in track:
            if msg.type == "set_tempo":
                return msg.tempo


def grouped_tracks_to_jnn(grouped_tracks, midif):
    # TODO: TORCH
    jnn_piece_ = copy.deepcopy(INSTRUMENTS)
    starts = []
    for g in grouped_tracks:
        if grouped_tracks[g]:
            jnn_piece_[g], start = parse_notes(
                mitracks.merge_tracks([track for i, track in enumerate(midif.tracks) if i in grouped_tracks[g]]))
            starts.append(start)
        else:
            jnn_piece_[g] = [None]  # No track

    if len(starts) > 1:
        start = min(starts)
        for g in jnn_piece_:
            for n in jnn_piece_[g]:
                if not n is None:
                    n[1] -= start

    return jnn_piece_


def parse_notes(track):
    # TODO: TORCH
    midi_note_messages = []
    for msg in mitracks._to_abstime(track):
        if msg.type == 'note_on' or msg.type == 'note_off':
            midi_note_messages.append(msg)
    notes = []
    start = None
    for i in range(0, len(midi_note_messages)):
        if midi_note_messages[i].type == 'note_on':
            if start is None:
                start = midi_note_messages[i].time
            new = [midi_note_messages[i].note, midi_note_messages[i].time, -midi_note_messages[i].time]
            for j in range(i + 1, len(midi_note_messages)):
                if midi_note_messages[j].type == 'note_off' and midi_note_messages[j].note == new[0]:
                    new[2] += midi_note_messages[j].time
                    break
            notes.append(new)
    return clean_identical_notes(notes, 128), start


def group_midi_tracks(midi_tracks):
    grouped_tracks = copy.deepcopy(INSTRUMENTS)
    for l in grouped_tracks:
        grouped_tracks[l].clear()
    for id, name, instrument in midi_tracks:
        grouped_tracks[instrument].append(id)
    return grouped_tracks


def parse_midi_tracks(midif):
    tracks = []
    for i, track in enumerate(midif.tracks):
        track_name = parse_midi_track_name(track)
        instrument_type = parse_midi_track_instrument(track)
        if not instrument_type is None:
            is_perc = False
            for perc_name in PERC_NAMES:
                if perc_name in track_name.lower():
                    is_perc = True
                    for perc_safe_name in PERC_SAFE_NAMES:
                        if perc_safe_name in track_name.lower():
                            is_perc = False
                            break

            is_lead = False
            for lead_name in LEAD_NAMES:
                if lead_name in track_name.lower():
                    is_lead = True

            if is_lead:
                tracks.append((i, track_name, 'lead'))
            elif not is_perc:
                tracks.append((i, track_name, instrument_type))
    return tracks


def parse_midi_track_instrument(track):
    for msg in track:
        if msg.type == 'program_change':
            for inst_type in INSTRUMENTS:
                for midi_index in INSTRUMENTS[inst_type]:
                    if msg.program == midi_index:
                        return inst_type
    return None


def parse_midi_track_name(track):
    for msg in track:
        if msg.type == 'track_name':
            return msg.name
        if msg.type == 'text':
            return msg.text
    return "null"


def jnn_to_midi(jnn_piece, full_midi_save_dir):
    """ JNN to MIDI. """
    tempo = jnn_piece.pop("tempo")
    midif = MidiFile(type=1)
    midif.tracks.append(generate_header_track(tempo))
    for channel, jnn_instrument in enumerate(jnn_piece):
        if not jnn_piece[jnn_instrument][0] is None:
            midif.tracks.append(jnn_track_to_midi_track(jnn_piece[jnn_instrument], jnn_instrument, channel))
    midif.save(full_midi_save_dir)
    return midif


def generate_header_track(tempo):
    # TODO: TORCH
    midit = MidiTrack()
    midit.append(MetaMessage("time_signature", numerator=4, denominator=4,
                             clocks_per_click=24, notated_32nd_notes_per_beat=8, time=0))
    midit.append(MetaMessage("set_tempo", tempo=int(tempo / 2), time=0))
    midit.append(MetaMessage("copyright", text=SIGNATURE))
    midit.append(MetaMessage("end_of_track", time=1))
    return midit


def jnn_track_to_midi_track(jnn_track, jnn_instrument, channel):
    # TODO: TORCH
    messages = [Message(type='program_change', channel=channel, program=JNN_INSTRUMENTS[jnn_instrument], time=0),
                MetaMessage("track_name", name=jnn_instrument, time=0)]
    for jnn_note in jnn_track:
        note, start, duration = jnn_note
        messages.append(Message(type="note_on", channel=channel, note=note, velocity=50, time=start))
        messages.append(Message(type="note_off", channel=channel, note=note, velocity=0, time=start + duration))
    messages.sort(key=lambda msg: msg.time)
    return MidiTrack(mitracks.fix_end_of_track(mitracks._to_reltime(messages)))


def jnnize_midi(full_raw_midi_dir, full_jnnized_midi_save_dir):
    """ JNN'ize raw MIDI file. """
    jnn_to_midi(midi_to_jnn(full_raw_midi_dir), full_jnnized_midi_save_dir)


def clean_identical_notes(notes, factor, mode=1):
    """ mode=0 : only removes completely identical notes
        mode=1 : removes all notes with the same pitch & starting time except the one with the longest duration"""
    if mode == 0:
        return [list(note) for note in {tuple(note) for note in notes}]
    elif mode == 1:
        note_time_dict = {}
        for note in notes:
            if int(note[1] / factor) not in note_time_dict.keys():
                note_time_dict[int(note[1] / factor)] = list([note])
            else:
                copy_note = [(i, existing) for i, existing in enumerate(note_time_dict[int(note[1] / factor)]) if
                             existing[0] == note[0]]
                if copy_note:
                    i, copy_note = copy_note[0]
                    if copy_note[2] < note[2]:
                        note_time_dict[int(note[1] / factor)][i] = note
                else:
                    note_time_dict[int(note[1] / factor)].append(note)
        notes = list()
        for t in note_time_dict:
            for note in note_time_dict[t]:
                notes.append(note)
        return notes
